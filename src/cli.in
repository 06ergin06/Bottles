#!@PYTHON@

# cli.in
#
# Copyright 2020 brombinmirko <send@mirko.pm>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


import gi
import os
import sys
import json
import signal
import argparse
import warnings

warnings.filterwarnings("ignore")  # suppress GTK warnings
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gio

VERSION = "@VERSION@"
pkgdatadir = "@pkgdatadir@"
# noinspection DuplicatedCode
gresource_path = f"{pkgdatadir}/bottles.gresource"
sys.path.insert(1, pkgdatadir)

signal.signal(signal.SIGINT, signal.SIG_DFL)

from bottles.params import *  # pyright: reportMissingImports=false
from bottles.backend.managers.manager import Manager
from bottles.backend.wine.cmd import CMD
from bottles.backend.wine.control import Control
from bottles.backend.wine.executor import WineExecutor
from bottles.backend.wine.reg import Reg
from bottles.backend.wine.regedit import Regedit
from bottles.backend.wine.taskmgr import Taskmgr
from bottles.backend.wine.uninstaller import Uninstaller
from bottles.backend.wine.winecfg import WineCfg
from bottles.backend.wine.explorer import Explorer
from bottles.utils import UtilsConnection


# noinspection DuplicatedCode
class CLI:
    default_settings = Gtk.Settings.get_default()
    utils_conn = UtilsConnection()
    settings = Gio.Settings.new(APP_ID)

    def __init__(self):
        # self.__clear()

        self.parser = argparse.ArgumentParser(description="Bottles is a tool to manage your bottles")
        self.parser.add_argument("-v", "--version", action="version", version=f"Bottles {VERSION}")
        self.parser.add_argument("-j", "--json", action="store_true", help="Outputs in JSON format")

        subparsers = self.parser.add_subparsers(dest='command', help='sub-command help')

        list_parser = subparsers.add_parser("list", help="List entities")
        list_parser.add_argument('type', choices=['bottles', 'components'], help="Type of entity")
        list_parser.add_argument("-f", "--filter", help="Filter bottles and components (e.g. '-f 'environment:gaming')")

        programs_parser = subparsers.add_parser("programs", help="List programs")
        programs_parser.add_argument("-b", "--bottle", help="Bottle name", required=True)

        tools_parser = subparsers.add_parser("tools", help="Launch WINE tools")
        tools_parser.add_argument('tool', choices=['cmd', 'winecfg', 'uninstaller', 'regedit', 'taskmgr', 'control',
                                                   'explorer'], help="Tool to launch")
        tools_parser.add_argument("-b", "--bottle", help="Bottle name", required=True)

        reg_parser = subparsers.add_parser("reg", help="Manage registry")
        reg_parser.add_argument('action', choices=['add', 'edit', 'del'], help="Action to perform")
        reg_parser.add_argument("-b", "--bottle", help="Bottle name", required=True)
        reg_parser.add_argument("-k", "--key", help="Registry key", required=True)
        reg_parser.add_argument("-v", "--value", help="Registry value", required=True)
        reg_parser.add_argument("-d", "--data", help="Data to be set")
        reg_parser.add_argument("-t", "--key-type", help="Data type",
                                choices=['REG_DWORD', 'REG_SZ', 'REG_BINARY', 'REG_MULTI_SZ'])

        self.__process_args()

    @staticmethod
    def __clear():
        os.system("clear")

    def __process_args(self):
        self.args = self.parser.parse_args()

        # LIST parser
        if self.args.command == "list":
            _filter = None if self.args.filter is None else self.args.filter
            _type = self.args.type

            if _type == "bottles":
                self.list_bottles(c_filter=_filter)
            elif _type == "components":
                self.list_components(c_filter=_filter)

        # PROGRAMS parser
        elif self.args.command == "programs":
            _bottle = self.args.bottle
            self.list_programs(_bottle)

        # TOOLS parser
        elif self.args.command == "tools":
            _bottle = self.args.bottle
            _tool = self.args.tool
            self.launch_tool(_bottle, _tool)

        # REG parser
        elif self.args.command == "reg":
            _bottle = self.args.bottle
            _action = self.args.action
            _key = self.args.key
            _value = self.args.value
            _data = self.args.data
            _key_type = self.args.key_type
            self.manage_reg(_bottle, _action, _key, _value, _data, _key_type)

    # region LIST
    def list_bottles(self, c_filter=None):
        mng = Manager(self, is_cli=True)
        mng.check_bottles()
        bottles = mng.local_bottles

        if c_filter and c_filter.startswith("environment:"):
            environment = c_filter.split(":")[1].lower()
            bottles = [b[0] for b in bottles.items() if b[1].get("Environment", "Custom").lower() == environment]

        if self.args.json:
            sys.stdout.write(json.dumps(bottles))
            exit(0)

        if len(bottles) > 0:
            sys.stdout.write(f"Found {len(bottles)} bottles:\n")
            for b in bottles:
                sys.stdout.write(f"- {b}\n")

    def list_components(self, c_filter=None):
        mng = Manager(self, is_cli=True)
        mng.check_runners(False)
        mng.check_dxvk(False)
        mng.check_vkd3d(False)
        mng.check_nvapi(False)
        mng.check_latencyflex(False)

        components = {
            "runners": mng.runners_available,
            "dxvk": mng.dxvk_available,
            "vkd3d": mng.vkd3d_available,
            "nvapi": mng.nvapi_available,
            "latencyflex": mng.latencyflex_available
        }

        if c_filter and c_filter.startswith("category:"):
            category = c_filter.split(":")[1].lower()
            if category in components:
                components = {category: components[category]}

        if self.args.json:
            sys.stdout.write(json.dumps(components))
            exit(0)

        for c in components:
            sys.stdout.write(f"Found {len(components[c])} {c}\n")
            for i in components[c]:
                sys.stdout.write(f"- {i}\n")

    # endregion

    # region PROGRAMS
    def list_programs(self, _bottle):
        mng = Manager(self, is_cli=True)
        mng.check_bottles()

        if _bottle not in mng.local_bottles:
            sys.stderr.write(f"Bottle {_bottle} not found\n")
            exit(1)

        bottle = mng.local_bottles[_bottle]
        programs = mng.get_programs(bottle)
        programs = [p for p in programs if not p.get("removed", False)]

        if self.args.json:
            sys.stdout.write(json.dumps(programs))
            exit(0)

        if len(programs) > 0:
            sys.stdout.write(f"Found {len(programs)} programs:\n")
            for p in programs:
                sys.stdout.write(f"- {p['name']}\n")

    # endregion

    # region TOOLS
    def launch_tool(self, _bottle, _tool):
        mng = Manager(self, is_cli=True)
        mng.check_bottles()

        if _bottle not in mng.local_bottles:
            sys.stderr.write(f"Bottle {_bottle} not found\n")
            exit(1)

        bottle = mng.local_bottles[_bottle]

        if _tool == "cmd":
            Cmd(bottle).launch()
        elif _tool == "winecfg":
            WineCfg(bottle).launch()
        elif _tool == "uninstaller":
            Uninstaller(bottle).launch()
        elif _tool == "regedit":
            Regedit(bottle).launch()
        elif _tool == "taskmgr":
            Taskmgr(bottle).launch()
        elif _tool == "control":
            Control(bottle).launch()
        elif _tool == "explorer":
            Explorer(bottle).launch()

    # endregion

    # region REG
    def manage_reg(self, _bottle, _action, _key, _value, _data, _key_type):
        mng = Manager(self, is_cli=True)
        mng.check_bottles()

        if _bottle not in mng.local_bottles:
            sys.stderr.write(f"Bottle {_bottle} not found\n")
            exit(1)

        bottle = mng.local_bottles[_bottle]
        allowed_types = ["REG_SZ", "REG_DWORD", "REG_BINARY", "REG_MULTI_SZ"]
        _key_type = "REG_SZ" if _key_type is None else _key_type.upper()

        if _action in ["add", "edit"]:
            if _data is None or _key_type not in allowed_types:
                sys.stderr.write(f"Missing or invalid data or key type\n")
                exit(1)
            Reg(bottle).add(_key, _value, _data, _key_type)
        elif _action == "del":
            Reg(bottle).remove(_key, _value)

    # endregion


if __name__ == '__main__':
    cli = CLI()
